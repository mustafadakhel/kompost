package com.mustafadakhel.kompost.android.lifecycle.fragment

import androidx.fragment.app.Fragment
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner
import com.mustafadakhel.kompost.core.DefaultProducer
import com.mustafadakhel.kompost.core.ProduceKey
import com.mustafadakhel.kompost.core.Producer
import com.mustafadakhel.kompost.core.kompostLogger
import com.mustafadakhel.kompost.core.producerOrNull

/**
 * A constant that holds the name of the [FragmentScopedFarm].
 * This name is used as part of the unique identifier when generating a [ProduceKey] for the [FragmentScopedFarm].
 */
private const val FragmentScopedFarmName = "FragmentScopedFarm"

/**
 * An extension property for [Fragment] that generates a [ProduceKey] for the [FragmentScopedFarm].
 * The [ProduceKey] is generated using the class of the fragment and the farmId as the tag.
 */
private val Fragment.fragmentScopedFarmProduceKey: ProduceKey
    get() = ProduceKey(this::class, tag = farmId)

/**
 * An extension property for [Fragment] that generates a unique identifier for the [FragmentScopedFarm].
 * The identifier is generated by concatenating the [FragmentScopedFarmName] and the hash code of the fragment.
 */
internal val Fragment.farmId: String
    get() = "$FragmentScopedFarmName.${this.hashCode()}"

/**
 * A class that represents a [FragmentScopedFarm] which is a type of [Producer].
 * It is constructed with a [Fragment] and an [ApplicationRootFragmentsFarm].
 * The [FragmentScopedFarm] is identified by the farmId of the fragment and is a child of the [ApplicationRootFragmentsFarm].
 *
 * @param fragment The [Fragment] associated with this [FragmentScopedFarm].
 * @param applicationRootFragmentsFarm The [ApplicationRootFragmentsFarm] that is the parent of this [FragmentScopedFarm].
 * @constructor Creates a new instance of [FragmentScopedFarm].
 */
class FragmentScopedFarm internal constructor(
    fragment: Fragment,
    applicationRootFragmentsFarm: ApplicationRootFragmentsFarm
) : Producer by DefaultProducer(id = fragment.farmId, parent = applicationRootFragmentsFarm)

/**
 * An extension function for [Fragment] that either retrieves an existing [FragmentScopedFarm] or creates a new one.
 * The function first tries to retrieve an existing [FragmentScopedFarm] using the [fragmentScopedFarmOrNull] function.
 * If an existing [FragmentScopedFarm] is not found, a new one is created using the [createFragmentScopedFarm] function.
 * The [productionScope] parameter is a lambda with [FragmentScopedFarm] as its receiver that is used to configure the [FragmentScopedFarm].
 * The [productionScope] is only used when a new [FragmentScopedFarm] is created.
 * The [fragmentsFarm] parameter is an instance of [ApplicationRootFragmentsFarm] which is used to retrieve or create the [FragmentScopedFarm].
 *
 * @param fragmentsFarm An instance of [ApplicationRootFragmentsFarm] which is used to retrieve or create the [FragmentScopedFarm]. Default value is the root fragments farm.
 * @param productionScope A lambda with [FragmentScopedFarm] as its receiver that is used to configure the [FragmentScopedFarm]. Default value is an empty lambda.
 * @return The existing or newly created [FragmentScopedFarm].
 */
fun Fragment.getOrCreateFragmentScopedFarm(
    fragmentsFarm: ApplicationRootFragmentsFarm = rootFragmentsFarm(),
    productionScope: FragmentScopedFarm.() -> Unit = {}
): FragmentScopedFarm {
    return fragmentScopedFarmOrNull(fragmentsFarm) ?: createFragmentScopedFarm(
        fragmentsFarm,
        productionScope
    )
}

/**
 * An extension function for [Fragment] that retrieves an existing [FragmentScopedFarm].
 * The function uses the [fragmentScopedFarmProduceKey] extension property to generate a [ProduceKey] for the [FragmentScopedFarm].
 * The [ProduceKey] is then used to check if a [FragmentScopedFarm] exists in the [ApplicationRootFragmentsFarm] associated with the [Fragment].
 * If a [FragmentScopedFarm] exists, it is returned. Otherwise, the function returns null.
 * The [fragmentsFarm] parameter is an instance of [ApplicationRootFragmentsFarm] which is used to check if a [FragmentScopedFarm] exists.
 *
 * @param fragmentsFarm An instance of [ApplicationRootFragmentsFarm] which is used to check if a [FragmentScopedFarm] exists. Default value is the root fragments farm.
 * @return The existing [FragmentScopedFarm], or null if it does not exist.
 */
internal fun Fragment.fragmentScopedFarmOrNull(
    fragmentsFarm: ApplicationRootFragmentsFarm = rootFragmentsFarm()
): FragmentScopedFarm? = producerOrNull(fragmentsFarm, fragmentScopedFarmProduceKey)


/**
 * An exception that is thrown when an attempt is made to create a [FragmentScopedFarm] that already exists.
 */
class FragmentScopedFarmAlreadyExistsException :
    IllegalStateException("Fragment farm already exists")

/**
 * An extension function for the [Fragment] class that creates a new [FragmentScopedFarm].
 * The function first checks if a [FragmentScopedFarm] already exists for the [Fragment] using the [fragmentScopedFarmOrNull] function.
 * If a [FragmentScopedFarm] already exists, the function throws a [FragmentScopedFarmAlreadyExistsException].
 * If a [FragmentScopedFarm] does not exist, a new one is created using the [FragmentScopedFarm] constructor.
 * The new [FragmentScopedFarm] is then configured using the [productionScope] parameter, which is a lambda with [FragmentScopedFarm] as its receiver.
 * After the [FragmentScopedFarm] is created and configured, it is added to the [ApplicationRootFragmentsFarm] associated with the [Fragment].
 *
 * @param fragmentsFarm An instance of [ApplicationRootFragmentsFarm] which is used to retrieve or create the [FragmentScopedFarm]. Default value is the root fragments farm.
 * @param productionScope A lambda with [FragmentScopedFarm] as its receiver that is used to configure the [FragmentScopedFarm].
 * @return The newly created [FragmentScopedFarm].
 * @throws FragmentScopedFarmAlreadyExistsException If a [FragmentScopedFarm] already exists for the [Fragment].
 */
fun Fragment.createFragmentScopedFarm(
    fragmentsFarm: ApplicationRootFragmentsFarm = rootFragmentsFarm(),
    productionScope: FragmentScopedFarm.() -> Unit = {}
): FragmentScopedFarm {
    if (fragmentScopedFarmOrNull(fragmentsFarm) != null)
        throw FragmentScopedFarmAlreadyExistsException()
    kompostLogger.log("Creating fragment farm for $this")
    return FragmentScopedFarm(this, fragmentsFarm)
        .apply(productionScope)
        .also {
            fragmentsFarm.produceFragmentFarm(
                fragment = this,
                farm = it
            )
        }
}

/**
 * A private extension function for the [ApplicationRootFragmentsFarm] class that produces a [FragmentScopedFarm] for a given [Fragment].
 * The function first generates a [ProduceKey] for the [FragmentScopedFarm] using the [fragmentScopedFarmProduceKey] extension property of the [Fragment].
 * The [Fragment]'s com.mustafadakhel.kompost.android.lifecycle is then observed and an [DefaultLifecycleObserver.onDestroy] callback is added.
 * In the [DefaultLifecycleObserver.onDestroy] callback, all crops of the [FragmentScopedFarm] are destroyed,
 * then the [FragmentScopedFarm] itself is destroyed from the [ApplicationRootFragmentsFarm].
 * Finally, the [FragmentScopedFarm] is produced in the [ApplicationRootFragmentsFarm] with the generated [ProduceKey] and the [FragmentScopedFarm] itself.
 *
 * @param fragment The [Fragment] for which the [FragmentScopedFarm] is to be produced.
 * @param farm The [FragmentScopedFarm] that is to be produced.
 */
private fun ApplicationRootFragmentsFarm.produceFragmentFarm(
    fragment: Fragment,
    farm: FragmentScopedFarm
) {
    val key = fragment.fragmentScopedFarmProduceKey
    kompostLogger.log("Producing fragment farm for $fragment with key $key")
    fragment.lifecycle.addObserver(object : DefaultLifecycleObserver {
        override fun onDestroy(owner: LifecycleOwner) {
            kompostLogger.log("Destroying fragment farm for $fragment with key $key")
            farm.destroyAllCrops()
            destroy(key)
            super.onDestroy(owner)
        }
    })
    produce(key) { farm }
}

/**
 * An inline function for [Fragment] that provides a lazy supply of a specified type [T].
 * The function uses the [lazy] function from the Kotlin standard library to provide a lazy initialization of the supply.
 * The supply is retrieved using the [fragmentSupply] function with the optional [tag] parameter.
 * The [tag] parameter is used as part of the [ProduceKey] when retrieving the supply.
 * The [tag] parameter is null by default.
 *
 * @param tag An optional tag that is used as part of the [ProduceKey] when retrieving the supply. Default value is null.
 * @return A [Lazy] delegate that provides a lazy initialization of the supply of type [T].
 */
inline fun <reified T> Fragment.lazyFragmentSupply(
    tag: String? = null
): Lazy<T> = lazy { fragmentSupply(tag) }

/**
 * An extension function for [Fragment] to supply an activity-scoped dependency.
 * This function retrieves the dependency from the [FragmentScopedFarm] associated with the [Fragment].
 * The [FragmentScopedFarm] is retrieved or created using the [getOrCreateFragmentScopedFarm] function.
 * The function takes an optional tag as a parameter, which is used as part of the [ProduceKey] to identify the dependency.
 * The function also takes an [ApplicationRootFragmentsFarm] as a parameter, which is used to retrieve or create the [FragmentScopedFarm].
 *
 * @param tag The tag to identify the dependency. Default value is null.
 * @param fragmentsFarm The [ApplicationRootFragmentsFarm] to retrieve or add the [FragmentScopedFarm] to. Default value is the root activities farm.
 * @return The retrieved dependency of type [T].
 */
inline fun <reified T> Fragment.fragmentSupply(
    tag: String? = null,
    fragmentsFarm: ApplicationRootFragmentsFarm = rootFragmentsFarm()
): T {
    return getOrCreateFragmentScopedFarm(fragmentsFarm)
        .supply(ProduceKey(T::class, tag = tag))
}
